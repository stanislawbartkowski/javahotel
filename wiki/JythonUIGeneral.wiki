#This page describes general idea behind MVP JythonUI framework

<wiki:toc max_depth="3*" />

= Introduction =

The purpose is to create convenient implementation of MVP (Model/View/Presenter) http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter framework.
 * View. XML files defining content of the page (window, dialog). It provides default layout (simplistic although functional) and allows also defining more customized view (HTML panel layout).
 * Model. Framework written in GWT/Java (client side) and Server/Java. Takes data from the Presenter and display it using XML Views. Also picks up events from the View, gets current data and raises proper method in the Presenter.
 * Presenter. Resides at the server side. Acts as an interface between background repository (for instance database) and UI. Provides action for View (user) events and implements all business logic. Provides also response to the user event (data and actions).

= Development =

Development requires defining XML file (user interface contents and buttons) and Presenter implementation written in Jython. Jython is interpreted language and does not require recompiling. This way way the development of View and Presenter can be done without typical J2EE/Java development. On the other hand Jython the advantage of Jython is easy access to Java libraries so all richness of Java is available for Jython development.
Framework acts as a "middleware" between View and Presenter. Creates user interface using View (XML files) and fills it with the date taken from the presenter. After user action (for instance clicking the button) sends all data to the Presenter and raises proper method at the server side. 
Current version support Jython only. It is planned in the future to allow also client customization (View enahancement by means of JavaScript code) and additional language for the server side (Presenter). For instances: C Python (by means of JNI) and Java itself.

= Details =

== Actions ==

=== Action list ===

|| Action name || Parameter || Parameter 1 || Parameter 2 || Description ||
|| JUP_DIALOG || Name of the XML file with the dialog  || || || Displays dialog as popup, modal dialog ||
|| JMAIN_DIALOG || Name of the XML file with the dialog || || || Displays dialog in main window, removes previous main dialog ||
|| JOK_MESSAGE || Window content || Window title || || Displays simple OK message ||
|| JERROR_MESSAGE || Window content || Window title || || Displays simple OK message but window is decorated as "error" message ||
|| JYESNO_MESSAGE || Window content || Window title || Action identifier. Action receives information is user action was yes/no. Boolean variable JYESANSWER holds true/false value || Displays Yes/No message windows ||
|| JCLOSE_DIALOG || || || || Opposite to JUP_DIALOG. Closes modal dialog and returns to upper dialog ||

=== Action in Jython code ===

{{{
  var[{Action name}] = True
  var['actionparam'] = {param value}
  var['actionparam1'] = {param1 value}  
  var['actionparam2'] = {param2 value}
}}}

Example:
{{{
  var['JOK_MESSSAGE'] = True
  var['actionparam'] = 'Hello message'
  var['actionparam1'] = 'Hello title'
}}}

=== Action in XML definition ===

<code language="xml">
  <button id={id} displayname={display name}  actiontype={action} actionparam={value of param}  actionparam1={value of param1} actionparam2={value of param2} />
</code>

Example: Display new main windows after clicking button "list"

<code language="xml">
  <button id="list" displayname="List" actiontype="JMAIN_DIALOG" actionparam="list.xml"/>
</code>

Jython equivalence:
{{{
  var['JMAIN_DIALOG'] = True
  var['actionparam'] = 'list.xml'
}}}

=== Sample related to JYESNO_MESSAGE ==

XML file:
<code language="xml">
<dialog>
...
 <buttons>
 <button id="clearPersons" displayname="Clear all" actiontype="JYESNO_MESSAGE" actionparam="Do you really want to remove all persons now ?" actionparam1="Warning before removing" actionparam2="clearpersons" />
 </buttons>
...
<dialog>
</code>

Jython code:
<code language="python">

def dialogaction(action,var) :
    
  if action == "clearpersons" :
     yes = var['JYESANSWER']
     if yes : do_seomethin_if_yes_answer 
     else : do_somenthing_if_no_answer

</code>

== CRUD actions ==

=== List of actions ===

|| Action name || Description ||
|| before || General action, should set list of items ||
|| crud_readlist || Call after every crud action, should retrieve list of items, similar to before. But 'before' is called only once at the beginning. ||
|| crud_add || Called when user clicked "Accept" in the "Add item" dialog. ||
|| crud_remove || Called when user clicked "Accept" in the "Remove item" window || 
|| crud_modif || Called when user clicked "Accept" in the "Modif item" window ||

=== Before and crud_readlist ===
"Before" is called once at the beginning to populate list for the first time. "crud_readlist" is called any time when list requires refreshing after adding, removing or changing an item.

Example
<code language="python">

def __create_list(op, var) :
    seq = op.getAllPersons()
    list = []
    
    for s in seq : 
       elem = {}
       elem["key"] = s.id
       elem["pnumber"] = s.getPersonNumb()
       elem["pname"] = s.getPersonName()
       list.append(elem)
       
    map={}   
    map["list"] = list
    var["JLIST_MAP"] = map

def dialogaction(action,var) :
    
  op = ServiceInjector.constructPersonOp()
          
  if action == "before" or action == "crud_readlist" :
    __create_list(op,var)
    return
</code>

=== crud_add, crud_modif and crud_remove ===

These action are called after user clicked "Accept" in appropriate window. These action should validate data and/or perform any background logic related to the action.
There are the following options available:
 # Invalid data. Data entered are invalid and action should return error message.
 # Data is valid but additional confirmation is required before completing the task
 # Data is valid and not confirmation is required. Action should be performed and list refreshing is necessary.
 # User answered "Yes" after conformation. Action should be performed and list refreshing is necessary.

=== Invalid data ===
Action should not set "JCLOSE_DIALOG" variable. Instead appropriate "JERROR_field" variable should be set with proper message text to display.
Example, assuming that pnumber field is invalid.
<code language="python">

  if action == "crud_add" :
     if duplicated :
          var["JERROR_pnumber"] = "Duplicated number, person number        should be unique"
          return
</code>

=== Confirmation is required ===
If additional confirmation is required before completing the action the two variables should be set.
 # JYESNO_MSSSAGE : should contain content of the yes/no window
 # JMESSAGE_TITLE : the title of the yes/no window

Example:
<code language="python">
  if action == "crud_add" and not var["JCRUD_AFTERCONF"] :
     var["JYESNO_MESSAGE"] = "Are you ready to add new elem ?"
     var["JMESSAGE_TITLE"] = "Ask for something"
     return
</code>

=== User answered "yes" after confirmation ===
Action is called and "JCRUD_AFTERCONF" variable is set to True. Action should performed necessary logic and set "JCLOSE_DIALOG" at the end.

<code language="python">
  if action == "crud_add" and var["JCRUD_AFTERCONF"] :
    .... do adding
    var["JCLOSE_DIALOG"] = True
    return
</code>

=== Data is valid and no confirmation is required ===
As above but no JCRUD_AFTERCONF checking is required. If conformation is not used then "JCRUD_AFTERCONF" variable is always set to False. Action should set "JCLOSE_DIALOG" variable to True.

== Move data from Jython to GUI ==

=== Fields values to form ===
 
<code language="python" >
  var['{name of the field}'] = {value}
  var["JCOPY_{name of the field}] = True
</code>

The first line set the new value and the second causes that this value is moved to the GUI form. Important: 'var' map is used to transport data from GUI to Jython and vice versa. As default the 'JCOPY_'+{name} is not set to True. One has to explicitly point which field should be refreshed after returning 'var' map to GUI.
The following value types are supported:
|| Type || Example ||
|| String || var['name'] = 'Abraham Lincol' ||
|| Boolean || var['ok'] = True ||
|| int value || var['position'] = 567 ||
|| long value || var['id'] = 345k54321122L ||
|| date || import datetime; var['start_from'] =  datetime.date(2001,11,5); ||
|| datetime || import datetime; var['modif_time'] = datetime.datetime(2017,01,13,20,45,14); ||

=== Lists to form ===
It is possible to move more then one list to the form.
<code language="python" >
    map={}   
    map[{list name in the form}] = {sequence}
    var["JLIST_MAP"] = map
</code>

'JLIST_MAP' contains map of lists. Key in the list is the name of the list in GUI form and the value is the sequence having list content.
Examples:
<code language="python" >
   list = []
    
    for i in range(100) : 
       elem = {}
       elem["key"] = i
       elem["pnumber"] = str(i)
       list.append(elem)
       
    map={}   
    map["list"] = list
    var["JLIST_MAP"] = map
</code>

== Custom (reusable) types with helper and enums ==

=== XML file with the definition ===

{{{
<?xml version="1.0"?>
<typedefs xmlns="http://www.jythongwt.typedefxsd.com">

<!-- common jython definition -->
     <jython>
       <import>from {package} import {module}</import>
       <method>{module}.{method}({0},{1})
      </jython>    

<!-- more the one typedef -->
  <typedef id="{type identifier}" type="combo" comboid="{id}" displayname = "{name}">
  

<!-- jython definition, overwrites common -->

     <jython>
        <method>{module}.{method}({0},{1})</method>
      </jython>    
 
   </typedef>

  <typedef id="{type identifier}" type="helper" comboid="{id}" displayname = "{name}">
  

<!-- jython definition, overwrites common -->

     <jython>
        <method>{module}.{method}({0},{1})</method>
      </jython>    

      <columns>
        <column id="{id1}" displayname="display name 1" />
        <column id="{id2}" displayname="display name 2" />
        .............
      </columns>  
 
   </typedef>

</typedefs>
}}}

Example:
{{{
<?xml version="1.0"?>
<typedefs xmlns="http://www.jythongwt.typedefxsd.com">

     <jython>
       <import>from testpack import packenum</import>
      </jython>    

  <typedef id="tenum" type="combo" comboid="id" displayname = "name">
  
     <jython>
        <method>packenum.dialogaction({0},{1})</method>
      </jython>    
 
   </typedef>

  <typedef id="tehelper" type="helper" comboid="id" displayname = "List of ids">
  
     <jython>
        <method>packenum.helperaction({0},{1})</method>
      </jython>
      
      <columns>
        <column id="id" displayname="Id" />
        <column id="name" displayname="Name" />
      </columns>  
 
   </typedef>
  
</typedefs>

}}}

'enum' define standard combo field, 'helper' define list with the values to select. After clicking on the helper image a list is displayed allowing choosing the value. The 'columns' tag defines list of columns visible. 'comboid' attribute define the 'id' of the column which is copied to the form field. The type name is 'tehelper'

Explanation:
First 'typedef' defines 'combo' type. The type name is 'teenum'. Jython code providing values is called as: 
<code language='python'>
from testpack import packenum
packenum.dialogaction(action,var)
</code>
The second defines selection helper. The type name is 'tehelper'. After clicking on the helper image a list with 'id' and 'name' columns. The 'columns' tag defines list of columns visible. 'comboid' attribute define the 'id' of the column which is copied to the form field. The type name is 'tehelper'
<code language='python'>
from testpack import packenum
packenum.helperaction(action,var)
</code>

=== Usage ===
{{{
<dialog xmlns="http://www.jythongwt.dialogxsd.com">

<!-- XML file name with typed definition used -->
 <types>{file name}</types>
 
 <form>
<!-- type name should be preceded with 'custom:' text -->
   <field id="combof" type="custom:{type id}" signalchange="" />
   
 </form>  

</dialog>

}}}

In the XML dialog file using the custom type a 'types' tag should a file name with custom types definition. In the 'form' definition a field should be preceded with 'custom:' name.

Example:
{{{
<code language="xml">
<dialog xmlns="http://www.jythongwt.dialogxsd.com">

<displayname>Combo Dialog</displayname>

 <before/>

 <types>typesenum.xml</types>
 
  <jython>
   <import>from testpack import packenum</import>
   <method>packenum.dialogaction({0},{1})</method>
 </jython>  
 
 <buttons>
  <button id="testcombo" displayname="Test" />
</buttons>
 
 
 <form>
   <field id="combof" type="custom:tenum" signalchange="" />
   
   <field id="comboenum" type="custom:tehelper" />
   
   <field id="outcombof" readonly="" />
 </form>  


</dialog>
</code>
}}}